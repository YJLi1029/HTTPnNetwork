# 11. 웹 공격 기술

# 웹 공격 기술

일반적으로 웹 공격 대상은 HTTP 자체보다는 HTTP를 사용하는 서버와 클라이언트, 그리고 서버 상에서 동작하는 웹 애플리케이션 등의 리소스이다. 

현재 인터넷에서 벌어지는 공격의 대부분은 웹사이트, 그 중에서도 웹 애플리케이션을 노리는 것이다.  



## 보안 기능이 없는 HTTP

 현재의 웹 사이트들은 초창기 버전과는 달리 대부분 인증, 세션관리, 암호화 등의 보안 기능이 필요하지만 HTTP에는 이러한 기능이 존재하지 않는다.

그렇기에 웹 애플리케이션에서 인증이나 세션 관리 기능을 개발자가 설계하고 구현해야 하는데, 기능마다 따로 설계를 하게 되기 때문에 각기 다르게 구현되어 보안 등급이 충분하지 못한 문제가 생길 수 있다.



## 리퀘스트 변조

웹 애플리케이션이 브라우저로부터 전달받은 HTTP 리퀘스트의 내용은 모든 클라이언트에서 자유롭게 변경할 수 있다. 그래서 웹 애플리케이션이 기대하던 값과는 다른 값이 보내질 수 있다.   

공격은 HTTP 리퀘스트 메시지에 공격 코드를 실어서 실행된다. 쿼리, 폼, HTTP 헤더, 쿠키 등 다양한 경로로 보내지기 때문에 웹 애플리케이션에 취약성이 있을 때는 정보를 유출당하거나 권한을 빼앗길 수 있다.



## 공격 패턴

웹 애플리케이션 대상의 공격 패턴은 능동과 수동, 두 가지로 나뉜다.



### 능동적 공격

능동적 공격에서 공격자는 직접 웹 애플리케이션에 액세스하여 공격 코드를 전송한다. 이러한 타입의 공격은 서버 상의 리소스에 직접 실행되어 공격자가 리소스에 액세스할 필요가 있다. 

능동적 공격의 예로는 SQL 인젝션과 OS 커맨드 등이 있다.



### 수동적 공격

수동적 공격에서 공격자는 함정을 이용해 유저에게 공격 코드를 실행시킨다. 수동적 공격에는 공격자가 직접 웹 애플리케이션에 액세스하여 공격하지 않고 다음 순서를 따른다.

- 공격자는 자신이 설치한 함정에 사용자를 유도한다. 이 때, 함정에는 공격 코드를 심어둔 HTTP 리퀘스트를 발생시키기 위한 장치가 심어져 있다.
- 사용자가 함정에 걸리면 유저의 브라우저나 메일 클라이언트에서 함정을 열게 된다.
- 브라우저에 있는 함정에서 HTTP 리퀘스트(공격 코드가 포함된)를 공격 대상인 웹 애플리케이션에 전송하고 공격 코드를 실행한다.
- 공격 코드를 실행하면 취약점이 있는 웹 애플리케이션에서 사용자가 가지고 있는 쿠키 등 기밀 정보를 도둑맞거나 로그인 중인 사용자의 권한이 악용될 수 있다.

대표적 수동적 공격으로는 크로스 사이트 스크립팅(XSS), 크로스 사이트 리퀘스트 포저리(CSRF) 등이 있다.

수동적 공격을 하면 인터넷에서 직접 액세스할 수 없는 네트워크를 공격할 수 있다. 공격자가 설치한 함정에 유저가 액세스할 수 있는 네트워크라면 인트라넷도 공격할 수 있다.

인트라넷에서는 인터넷을 통해 웹사이트에 액세스하거나 인터넷에서 전송되어 온 메일을 읽을 수도 있기 때문에 공격자는 사용자를 함정으로 유도해 인트라넷을 공격할 수 있게 되는 것이다.



# 출력 값의 이스케이프 미비로 인한 취약성

웹 애플리케이션의 보안 대책을 실시하는 장소를 크게 나누면 다음과 같다.



### 클라이언트에서 체크

클라이언트 측에서의 체크는 대부분 JavaScript를 사용한다. 그러나 변조나 무효화의 가능성이 있기 때문에 근본적인 보안 대책으로는 적합하지 않다. 그래서 클라이언트 측의 체크는 입력 실수를 바로잡는 UI 향상을 위한 정도로 사용한다.   



### 웹 애플리케이션에서 체크

웹 애플리케이션 측에서의 입력값 체크보다는 출력값의 이스케이프가 보안 대책으로 중요하다. 출력 값의 이스케이프가 미비할 경우 공격자가 보낸 공격 코드가 출력하는 대상에 피해를 입힐 수 있다.



## 크로스 사이트 스크립팅(XSS)

크로스 사이트 스크립팅(XSS)은 취약성이 있는 웹사이트를 방문한 사용자의 브라우저에서 악의적인 HTML 태그가 사용자의 세션을 탈취하여 공격자가 원하는 목적을 동작시키는 공격이다.   
이는 공격자가 작성한 스크립트가 함정이 되고 유저의 브라우저 상에서 움직이는 수동적 공격이다. 

 
URL의 쿼리에 존재하는 XSS 취약점을 파고들어 공격자가 메일이나 함정 웹페이지 등을 설치하게 되고, 사용자가 URL을 클릭하도록 유도한다.   
URL을 열어도 얼핏 보기에는 달라진 것이 없지만, 설치한 스크립트가 동작하고 있어 사용자가 ID와 패스워드를 입력하면 공격자에게 정보가 유출된다. 그 후, 공격자가 얻어낸 ID와 패스워드를 이용해 원래 사이트에 로그인해도 유저는 정보가 유출된 것을 알아채지 못할 가능성이 높다.   



※ 유저의 쿠키를 빼앗는 공격

폼에 함정을 설치하는 것 말고도 스크립트를 추가하여 XSS로 유저의 쿠키를 빼앗을 수 있다.



## SQL 인젝션

SQL 인젝션이란 웹 애플리케이션을 이용하고 있는 데이터베이스에 SQL을 부정하게 실행하는 공격이다. 굉장히 중요한 취약점으로 개인 정보나 기밀 정보 누설로 직결되기도 한다.

대부분의 웹 애플리케이션은 데이터베이스를 이용하고 있고, 테이블 내의 데이터 검색 및 추가, 삭제와 같은 처리가 발생할 경우 SQL을 사용해서 데이터베이스에 액세스한다. 

만약에 SQL의 호출 방법에 문제가 있을 경우, 의도치 않은 SQL 삽입문이 인젝션 되어 실행되는 경우가 있다.

SQL 인젝션에 의한 피해로는 다음과 같다.

- 데이터베이스 내의 데이터 부정 열람이나 변조
- 인증 회피
- 데이터베이스 서버를 경유한 프로그램 실행 등

※ SQL이란?

SQL은 관계형 데이터 베이스 관리 시스템(RDBMS)에 대해서 조작하는 데이터베이스 언어로, 데이터 조작이나 데이터의 정의 등을 하기 위한 것이다. 데이터베이스를 이용한 웹 애플리케이션에서는 무언가의 방법으로 RDBMS에 대해 SQL문을 송신하고 RDBMS에서 얻은 결과를 웹 애플리케이션에서 활용한다. 



### 동작 예(?)

SQL 인젝션은 공격자에 의해 개발자가 의도하지 않는 형태로 SQL 문장이 변경되어 구조가 파괴되는공격이다. 실제로 SQL 인젝션이 발생한 경우에는 유저 정보나 결제 정보 등의 다른 테이블을 부정하게 열람하거나 변조되는 등의 피해가 발생할 수 있다.



## OS 커맨드 인젝션

OS 커맨드 인젝션이란 우베 애플리케이션을 경유하여 OS 명령을 부정하게 실행하는 공격이다. 웹 애플리케이션에서는 OS에서 사용되는 커맨드를 쉘을 경유해 실행할 수 있다. 쉘을 호출하는 방법에서 취약한 부분이 있다면 잘못된 OS 커맨드가 삽입될 수 있다. 

OS 커맨드 인젝션은 Windows와 Linux 등의 커맨드 라인에서 프로그램을 기동하는 쉘에 대해 커맨드를 보낼 수가 있는데, OS 상에서 동작하는 다양한 프로그램을 실행할 수 있다. 

OS 커맨드 인젝션의 공격 예로는 메일 송신 기능을 들 수 있다. 



## HTTP 헤더 인젝션

HTTP 헤더 인젝션 이란 공격자가 리스폰스 헤더필드에 개행 문자 등을 삽입함으로써 임의의 리스폰스 헤더 필드나 바디를 추가하는 수동적 공격이다. 특히, 바디를 추가하는 공격을 HTTP 리스폰스 분할공격 이라고 부른다.

웹 애플리케이션에서는 리스폰스 헤더 필드 Location과 Set-Cookie의 값에 외부에서 받은 값을 삽입하는 일이 있다. HTTP 헤더 인젝션은 이러한 리스폰스 헤더 필드에 값을 출력하는 처리가 있던 곳에 개행 문자를 삽입함으로써 발생할 수 있다. 

```html
ex) Location : http://www.example.com/a.cgi?q=12345
		Set-Cookie : UID=12345

	*12345가 삽입된 값
```

HTTP 헤더 인젝션에 의해 다음과 같은 피해를 받을 수 있다.

- 임의의 쿠키 세트
- 임의의 URL에 리다이렉트
- 임의의 바디 표시(HTTP 리스폰스 분할 공격)



**HTTP 헤더 인젝션의 공격 사례**

1. 카테고리를 선택하여 해당 각 카테고리의 페이지로 리다이렉트하는 기능을 들 수 있다. 이 기능은 카테고리마다 카테고리 ID가 설정되어 있고, 카테고리를 선택하면 리스폰스에 Location 헤더 필드 내에 그 값이 반영되어 리다이렉트 된다. 

    공격자는 카테고리 ID를 고쳐서 리퀘스트를 보내고, 리스폰스를 반환받는다. 이 때 Set-Cookie 헤더 필드가 유효하기 때문에 공격자가 지정한 임의의 쿠키가 세팅되어 버린다. 이것은 세션 픽세이션(Session Fixation)이라는 공격자가 지정한 세션 ID를 사용하게 하는 공격과 조합함으로써 유저로 위장할 가능성이 있다. 

    공격자가 입력한 문자는 원래 Location 헤더 필드의 쿼리 값이 되어야 하지만 개행 문자로 해석되어 버려 새로운 헤더 필드가 추가되는 결과를 초래한다.  이로 인해 공격자는 임의의 헤더 필드를 리스폰스에 삽입할 수 있다. 

2. HTTP 리스폰스 분할 공격또한 예로 들 수 있는데, 이는 HTTP 헤더 인젝션을 응용한 공격이다. 공격 순서는 같고 삽입하는 문자열에 개행 문자를 두 개 나란히 보낸다. 개행 문자가 두 개 연속함으로써 HTTP 헤더와 바디를 나누는 빈 행을 만들어 내고 가짜 바디를 표시하는 공격이다. 

이 공격에 의해 함정에 빠진 유저의 브라우저에 가짜 웹페이지를 표시해서 개인 정보를 입력하게 하거나 크로스 사이트 스크립팅과 같은 효과를 얻을 수 있다. 



## 메일 헤더 인젝션

메일 헤더 인젝션은 웹 애플리케이션의 메일 송신 기능에 공격자가 임의의 To 및 Subject 등의 메일 헤더를 부정하게 추가하는 공격이다. 취약성이 있는 웹 사이트를 이용해 스팸 메일이나 바이러스 메일 등을 임의의 주소에 송신할 수 있다. 



**메일 헤더 인젝션의 공격 사례**

메일 헤더 인젝션의 예시로는 웹 페이지의 문의 양식을 만들어 폼에 송신자의 메일 주소와 문의 내용을 입력하면 관리자에게 메일이 송신되는 기능이다. 



## 디렉토리 접근 공격

디렉토리 트래버설(Directory Traversal)이란 비공개 디렉토리의 파일에 대해서 부정하게 디렉토리 패스를 가로질러 액세스하는 공격이다. 이 공격을 패스 트래버설(Path Traversal)이라고 부르기도 한다. 

웹 애플리케이션 파일을 조작하는 처리에서 파일 이름을 외부에서 지정하는 처리가 취약할 경우 유저는 [../]등의 상대 경로를 지정하거나 [/etc/passwd]등의 절대경로를 지정함으로써 임의의 파일이나 디렉토리에 액세스 할 수 있다. 이로 인해 웹 서버 상의 파일이 잘못 열람되거나 변조 또는 삭제되어 버릴 수 있다. 

디렉토리 트래버설 공격 사례

예시로는 파일을 읽고 표시하는 기능을 들 수 있다. 이 기능은 쿼리에 파일명을 지정하는 것으로 /www/log/ 이하에 지정된 파일을 읽어오는 것이다. 공격자는 쿼리를 지정한 리퀘스트를 보내고, 퀄니느 공격자가 노리고 있는 파일 /etc/passwd을 읽기 위해 /www/log에서 상대 경로를 지정하고 있다. 만약 read.php가 디렉토리를 지정받을 수 있다면 공개를 원치 않는 파일에 액세스 할 수 있다. 



## 리모트 파일 인클루션

리모트 파일 인클루션은 스크립트의 일부를 다른 파일에서 읽어올 때 공격자가 지정한 외부 서버의 URL을 파일에서 읽게 함으로써 임의의 스크립트를 동작시키는 공격이다. 

주로 PHP에서 발생하는 취약성으로, PHP include와 require 설정에 따라서 외부 서버의 URL을 파일명으로 지정할 수 있는 기능이다. 위험성 때문에 PHP 5.2.0 이후로는 초기에 무효로 설정되어 있다. 

출력 값의 이스케이프 문제로 볼 수도 있지만 임의의 파일명을 지정할 수 없도록 하여야 한다. 



**리모트 파일 인클루션의 공격 사례**

리모트 파일 인클루션의 예로 쿼리에서 지정한 파일을 include에 의해 읽어들이는 기능을 들 수 있다.  이 기능은 쿼리에 파일 이름을 지정함으로써, include에 의해 스크립트에 다른 파일을 읽어들이는 기능이다. 

웹 서버에서 include가 외부 서버의 URL을 지정할 수 있는 경우, 공격자가 준비한 외부 서버의 URL을 읽어 올 수 있다. 그 결과, system에 의해 쿼리에 지정한 OS 커맨드를 웹 서버 상에서 실행할 수 있게 된다. 



# 웹 서버의 설정이나 설계 미비로 인한 취약성

웹 서버를 잘못 설정하거나 잘못 설계할 떄 생긴 문제 등에 의해 발생하는 취약성이다. 



## 강제 브라우징

강제 브라우징(Forced Browsing)은 웹 서버의 공개 디렉토리에 있는 파일 중에서 공개 의도가 없는 파일이 열람되게 하는 것이다. 

강제 브라우징을 받을 수 있는 피해는 다음과 같다

- 고객 정보 등 중요 정보 누설
- 본래 액세스 권한이 있는 사용자에게만 표시하지 않는 정보 누설
- 어디에서도 링크되지 않은 파일 누설

공개하고 싶지 않은 파일의 URL을 숨기는 보안 대책에 의존하는 경우 해당 URL을 알게 되면 파일을 열람할 수 있게 된다. 예측하기 쉬운 파일이나 디렉토리의 인덱스가 표시된 경우, 어떠한 방법으로 URL이 누설되었을 경우에도 발생할 가능성이 있다. 

※ 인증이 필요한 웹 페이지에서 이용되는 파일(HTML파일, 이미지, PDF 등의 문서, CSS, 기타 데이터 등)의 URL을 지정해서 직접 액세스할 수 있다. 



**강제 브라우징 취약성의 예**

어떤 사람의 SNS는 친구 관계를 맺고 있는 유저만 액세스할 수 있도록 되어있다. 그러나 그 SNS의 내용에 첨부된 이미지의 URL을 알고 있으면 이 SNS에 액세스 권한이 없더라도 직접 URL을 지정하여 이미지를 표시할 수 있다. 이미지는 액세스 제어 대상으로 하지 않았기 때문에 발생하는 취약성이다. 



## 부적절한 에러 메시지 처리

부적절한 에러 메시지 처리는 공격자에게 유익한 정보가 우베 애플리케이션의 에러 메시지에 포함된다는 취약성이다. 웹 애플리케이션에 관계된 주요 에러 메시지에는 다음과 같은 것들이 있다.



### 웹 애플리케이션에 의한 에러 메시지

인증 기능의 인증 에러를 예로 부적절한 에러 메시지 처리를 설명한다.  이 기능은 입력한 메일 주소와 패스워드의 조합이 잘못되었을 때 에러 메시지를 표시하는 기능이다. 

공격자는 이 에러 메시지를 이용해 입력한 메일 주소가 웹 사이트에 등록되어 있는지 여부를 확인할 수 있다. 오류 메시지를 공격의 힌트로 이용되지 않게 하지 위해서는 [인증 에러입니다]라는 정도의 내용을 표시할 필요가 있다.



### 데이터베이스 등의 시스템에 의한 에러 메시지

검색 기능 오류를 예로 부적절한 에러 메시지 처리를 설명한다. 이 기능은 검색을 수행하는 기능에서 예상하지 못한 문자열이 입력되었을 때 데이터베이스의 에러가 표시된다. 

시스템이 출력하는 오류에는 다음과 같은 것들이 있다

- PHP나 ASP 등의 스크립트 에러
- 데이터베이스나 미들웨어의 에러
- 웹 서버 에러



## 오픈 리다이렉트

오픈 리다이렉트는 지정한 임의의 URL로 리다이렉트하는 기능이다. 리다이렉트되는 곳의 URL에 악의가 있는 웹사이트가 지정된 경우 유저가 그 웹사이트로 유도되는 취약성과 연결된다. 



**오픈 리다이렉트의 공격 사례**

이 예로는 파라미터로 지정한 URL에 리다이렉트하는 기능을 들 수 있다. 공격자는 리다이렉트 파라미터를 함정을 설치한 웹 사이트로 고쳐놓는다. 그러면 유저는 원래 들어가려고 했던 사이트가 아니더라도 공격자가 지정한 웹사이트로 이동하게 된다. 피싱 사기 등이 일어나기 쉬운 수단이다. 



# 세션 관리 미비로 인한 취약성

세션 관리는 유저의 상태를 관리하기 위한 기능이지만 이 세션 관리 기능이 취약한 경우 유저 인증 상태를 빼앗겨 버리는 피해가 발생한다. 



## 세션 하이잭

세션 하이잭은 공격자가 어떠한 방법으로 유저의 세션 ID를 입수하여 악용하는 것으로, 유저로 위장하는 공격이다. 

인증 기능이 있는 웹 애플리케이션에서는 세션 ID를 사용한 세션 관리 기구에 의해 인증 상태를 관리하는 방법이 대부분이다. 클라이언트에서는 쿠키 등에 세션 ID를 기록하고 서버에서는 세션 ID와 인증 상태 등을 연동해 관리하고 있다. 

공격자가 세션 ID를 입수하는 방법으로는 다음과 같은 것이 있다.

- 부적절한 생성 방법에 의한 세션 ID 추측
- 도청이나 XSS 등에 의한 세션 ID 도용
- 세션 고정 공격에 의한 세션 ID 강제



**세션 하이잭의 공격 사례**

인증 기능을 예로 세션 하이잭을 설명할 수 있다. 이 기능은 세션 관리 기구에 의해 인증된 유저는 세션 ID(SID)를 유저의 브라우저의 쿠키에 갖고 있다는 것이다. 

웹 사이트에 XSS 취약성이 있다는 것을 알게 된 공격자는 document.cookie를 공격자에게 송신하는 JavaScript를 사용한 함정을 설치한다. 유저가 함정에 걸리면 공격자는 세션 ID를 포함한 쿠키를 입수할 수 있다. 

유저의 세션 ID를 입수한 공격자는 브라우저의 쿠키에 세션 ID를 세팅하고 웹 사이트에 액세스하여 유저로 위장할 수 있다. 



## 세션 픽세이션

세션 하이잭이 상대의 세션 ID를 뺏는 공격이었다면, 세션 픽세이션(Session Fixation)은 공격자가 지정한 세션 ID를 유저에게 강제적으로 사용하게 하는 공격으로, 수동적 공격이다. 세션 고정 공격이라고도 불린다. 



**세션 픽세이션 공격 사례**

세션 픽세이션의 예로는 인증 기능을 들 수 있다. 어떤 웹 사이트의 인증 기능은 인증 전에 세션 ID를 발행하고, 인증이 성공하면 서버 내에서의 상태가 변경된다. 

공격자는 함정 준비를 위해 웹 사이트에 액세스하여 세션 ID를 입수한 후 공격자는 이 세션 ID를 유저가 강제적으로 이용하도록 함정을 준비한다. 유저가 이 세션 ID를 이용해 인증을 하게 되면 세션 ID는 서버 상에서 유저가 인증한 상태로 변경되어 기록된다. 공격자는 사용자가 함정에 걸린 시기를 가늠하여 조금 전의 세션 ID로 웹 사이트에 유저로서 액세스할 수 있다. 



※ 세션 어댑션

세션 어댑션(Session Adaption)은 PHP나 [ASP.NET](http://asp.NET) 등에 존재하는 미지의 세션 ID를 받아들이는 기능이다. 이 기능을 악용하면 세션 픽세이션의 준비단계에 필요했었던 웹사이트에게 세션 ID를 발행받는 수고를 생략할 수 있게 된다. 즉, 공격자는 마음대로 세션 ID를 작성하여 함정을 준비하고 미들웨이에서 그 세션 ID를 미지의 세션 ID로 받아들이게 된다. 



## 크로스 사이트 리퀘스트 포저리

크로스 사이트 리퀘스트 포저리(CSRF, Cross-Site Request Forgeries)는 인증된 유저가 의도하지 않는 개인 정보나 설정 정보 등을 공격자가 설치해 둔 함정에 의해 어떤 상태를 갱신하는 처리를 강제로 실행시키는 공격으로 수동적 공격이다. 

크로스 사이트 리퀘스트 포저리에 의해 다음과 같은 피해를 얻을 수 있다

- 인증된 유저의 권한으로 설정 정보 등을 갱신
- 인증된 유저의 권한으로 상품을 구입
- 인증된 유저의 권한으로 게시판에 글 작성



**CSRF의 공격 사례**

유저가 이미 게시판에 인증된 상태이고, 이 유저의 브라우저의 쿠키에는 웹 사이트에 인증된 상태의 세션 ID가 있다. 공격자는 유저가 액세스하면 게시판에 의도치 않는 코멘트를 추가하는 리퀘스트를 발행하는 함정을 준비해 둔다. 유저의 브라우저가 이 함정을 실행하면 유저의 권한으로 게시판에 코멘트가 추가된다. 만약, 함정을 실행했을 때 유저가 인증이 되지 않았다고 한다면 유저의 권한으로 게시판에 코멘트가 추가될 일은 없다. 



# 기타

## 패스워드 크래킹

패스워드 크래킹(Password Cracking)은 패스워드를 이끌어내어 인증을 돌파하는 공격이다. 웹 애플리케이션 이외의 시스템(FTP, SSH 등)에서도 쓰이는 공격이지만, 여기에서는 인증 기능을 제공하고 있는 웹 애플리케이션에 대해서만 다룬다. 

패스워드 크래킹에는 다음과 같은 방법이 있다.

- 네트워크 경유로 패스워드 시행
- 암호화된 패스워드를 해독(공격자가 시스템에 침입하는 바업 등을 통해서 암호화나 해시화된 패스워드의 데이터를 취득한 상황)

이 외에도 인증을 돌파하는 공격으로는 SQL 인젝션이나 XSS 등이 있다. 



### 네트워크 경유로 패스워드 시행

웹 애플리케이션이 제공하는 인증 기능에 대해 네트워크 경유로 패스워드 후보를 시험해 보는 공격이다. 여기에는 다음과 같은 방법이 있다. 

- 무차별 대입 공격

    모든 키의 집합 키 공간(keyspace), 즉 비밀 번호 시스템에서 취할 수 있는 모든 패스워드 후보를 시험해서 인증을 돌파하는 공격이다. 그러나, 키 공간이 커지면 현실적으로 패스워드를 맞히는 데 상당한 시간이 걸릴 수 있다.

- 사전 공격

    사전 공격(Dictionary Attack)은 사전에 패스워드 후보(사전)을 준비해 두고 그것을 사용하여 인증을 돌파하는 공격이다. 무차별 공격에 비해 시험할 후보가 적으므로 공격 시간을 단축할 수 있다. 다만, 사전 중에 올바른 패스워드가 없다면 해독할 수 없다. 



### 암호화된 패스워드를 해독

웹 애플리케이션으로 이용하는 패스워드를 보존할 경우, 패스워드를 평문 그대로 보존하지 않고 해시 함술르 사용해 해시화나 salt 등의 방법으로 암호화한다. 공격자가 어떠한 수단으로 패스워드 데이터를 훔쳤다 하더라도 이를 이용하기 위해서 해독하는 등 평문을 손에 넣어야 한다. 

암호화된 데이터로부터 평문을 도출하는 방법으로는 다음과 같은 것이 있다.

- 무차별 대입 공격/사전 공격에 의한 유추
- 레인보우 테이블
- 열쇠 입수
- 암호 알고리즘의 취약성



**무차별 대입 공격/사전 공격에 의한 유추**

암호화에 해시 함수를 사용한 경우, 무차별 대입 공격이나 사전 공격과 같은 수법으로 패스워드 후보에 같은 해시 함수를 적용해 시험해 보면서 해시 값을 만들어 내서 패스워드를 유추할 수 있습니다. 



**레인보우 테이블**

레인보우 테이블(Rainbow Table)은 평문과 그에 대응하는 해시 값으로 구성된 데이터베이스 테이블입니다. 사전에 거대한 테이블ㅇ르 만들어 무차별 대입 공격/사전 공격 등에 걸리는 시간을 단축하는 테크닉이다. 레인보우 테이블에서 해시 값을 검색해 이에 맞는 평문을 이끌어 낼 수 있습니다. 



**열쇠 입수**

패스워드의 데이터가 공통키 암호 등으로 암호화되어 있을 때 암호화에 사용된 키를 어떤 방법으로든 입수하게 되면 복호화할 수도 있다.



**암호 알고리즘의 취약성**

암호 알고리즘의 취약성을 파고들어 패스워드를 해독하는 방법도 생각할 수 있지만 널리 사용되고 있는 암호 알고리즘은 취약성이 발견될 가능성이 낮기 때문에 성공하기는 어렵다. 

우베 애플리케이션의 개발자가 독자적인 암호 알고리즘을 구현한 경우에는 충분히 검증되지 않은 취약성이 존재할 가능성도 있다.



## 클릭 재킹

클릭 재킹(Click Jacking)은 투명한 버튼이나 링크를 함정으로 사용할 웹페이지에 심어두고, 유저에게 링크를 클릭하게 함으로써 의도하지 않은 콘텐츠에 액세스시키는 공격이다. UI Redressing 이라고도 불린다. 

함정 페이지에는 보기에 무해한 내용이나 클릭하고 싶어지는 링크를 심어둔다. 



**클릭 재킹의 공격 사례**

SNS 사이트의 탈퇴 처리를 예로 클릭 재킹을 설명한다. 이 기능은 로그인 중인 SNS 유저가 [탈퇴]라는 버튼을 클릭해서 SNS 사이트에서 탈퇴 처리를 실행한다는 것이다. 

공격자는 함정으로 유저가 클릭하고 싶어질만한 웹페이지를 준비하고 SNS에 로그인 중인 유저가 함정 사이트에 방문하여 투명버튼을 누른다면 함정이 실행되게 된다. 



## DoS 공격

DoS(Denial of Service attack)은 서비스 제공을 정지 상태로 만드는 공격이다. 서비스 정지 공격 또는 서비스 거부 공격이라고도 불린다. DoS 공격은 웹사이트 뿐만 아니라 네트워크 기기나 서버 등을 대상으로 공격하는 경우도 있다. 

주요 DoS 공격 방법은 다음과 같다.

- 액세스를 집중시킴으로써 부하를 걸어 리소스를 다 소비하게 해 사실상 서비스를 정지 상태로 만든다.
- 취약성을 공격해 서비스를 정지시킨다.

이 중에서도 액세스를 집중시키는 DoS 공격은 대량의 액세스를 보낸다는 점에서 단순해 보이지만, 공격 이외의 정상적인 액세스와 구별이 힘들다는 이유도 있어 방지하는 것은 쉽지 않다. 

여러 대의 컴퓨터가 실행하는 DoS 공격은 DDoS 공격(Distributed Denial of Service attack)이라고 불린다. 



## 백도어

백도어(BackDoor)는 제한된 기능을 정규 절차를 밟지 않고 이용하기 위해 설치된 뒷문이다. 백도어를 사용하면 본래 정해진 제한을 초과한 기능을 이용하는 것이 가능하다. 

주요 백도어의 종류로는 다음과 같은 종류가 있다. 

- 개발 단계에 디버그용으로 추가한 백도어
- 개발자가 자기 자신의 이익을 위해서 추가한 백도어
- 공격자가 어떠한 방법을 써서 설치한 백도어

백도어용 프로그램이 설치된 경우에는 프로세스나 통신을 감시해서 발견하는 것도 가능하지만, 웹 애플리케이션을 수정해서 설치한 백도어는 정상적으로 이용하는 것과 구별하기 어렵기 때문에 발견하기가 쉽지 않다.